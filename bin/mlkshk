#!/usr/bin/env python

import base64
from datetime import datetime
from functools import wraps
import json
from hashlib import md5, sha1
import hmac
import logging
import os.path
import random
import sys
import time
from urllib import urlencode
from urlparse import urljoin, urlsplit
import webbrowser

import httplib2
from poster.encode import multipart_encode
from poster.streaminghttp import register_openers
from termtool import Termtool, subcommand, argument
import urllib2


class SignedHttp(httplib2.Http):

    def __init__(self, args, cache=None, timeout=None, proxy_info=None):
        httplib2.Http.__init__(self, cache, timeout, proxy_info)
        self.site = args.site
        self.api_key = args.api_key
        self.api_secret = args.api_secret
        self.access_token, self.access_secret = args.access_token.split(':', 1)

    def sign_request(self, uri, method):
        timestamp = int(time.mktime(datetime.utcnow().timetuple()))
        nonce = md5("%s" % random.random()).hexdigest() #you might want to generate better nonces

        uri = urljoin(self.site, uri)
        logging.debug("Signing request for URL %s", uri)
        uriparts = urlsplit(uri)
        if ':' in uriparts.netloc:
            host, port = uriparts.netloc.split(':', 1)
        else:
            host, port = uriparts.netloc, '80'  # even if it's https (API bug)

        normalized_string = '\n'.join((self.access_token, str(timestamp), nonce, method, host, port, uriparts.path))
        normalized_string += '\n'  # plus a trailing nl for the path
        # note, we're not including the query string because there isn't one.

        # now we sign the request
        digest = hmac.new(self.access_secret.encode('ascii'), normalized_string, sha1).digest()
        signature = base64.encodestring(digest).strip() # we strip the end off because it gives us a \n at the end
        authorization_string = 'MAC token="%s", timestamp="%s", nonce="%s", signature="%s"' % (self.access_token, str(timestamp), nonce, signature)

        return uri, authorization_string

    def request(self, uri, method="GET", body='', headers=None,
        redirections=httplib2.DEFAULT_MAX_REDIRECTS, connection_type=None):

        headers = {} if headers is None else dict(headers)
        uri, headers['Authorization'] = self.sign_request(uri, method)
        return httplib2.Http.request(self, uri, method, body, headers, redirections, connection_type)


def authd(fn):
    @wraps(fn)
    def moo(self, args):
        if not all((args.api_key, args.api_secret, args.access_token)):
            logging.error("Not configured to use MLKSHK API yet; try 'configure' command first")
            sys.exit(1)

        client = SignedHttp(args)
        return fn(self, args, client)
    return moo


@argument('--site', default='https://mlkshk.com/', help='site at which to talk to MLKSHK')
@argument('--api-key', help='MLKSHK application API key')
@argument('--api-secret', help='MLKSHK application API secret')
@argument('--access-token', help='MLKSHK access token (in `token:secret` format)')
class Mlkshk(Termtool):

    description = 'Control MLKSHK from the command line.'

    @subcommand(help='configures the API keys')
    @argument('--redirect-url', help='MLKSHK application redirect URL')
    def configure(self, args):
        if not args.api_key:
            args.api_key = raw_input('API key: ')
        if not args.api_secret:
            args.api_secret = raw_input('API secret: ')
        if not args.redirect_url:
            args.redirect_url = raw_input('Redirect URL: ')
        if not args.access_token:
            data_store = dict()
            logging.debug("TOKEN IS: %r", args.api_key)

            auth_url = urljoin(args.site, '/api/authorize?response_type=code&client_id=%s&redirect_uri=%s' % (args.api_key, args.redirect_url))
            webbrowser.open(auth_url, new=1)

            verifier = raw_input("Code: ")

            access_req_data = {
                'grant_type': 'authorization_code',
                'code': verifier,
                'redirect_uri': args.redirect_url,
                'client_id': args.api_key,
                'client_secret': args.api_secret,
            }
            access_req = urlencode(access_req_data)
            logging.debug("ACCESS REQUEST: %s", access_req)

            h = httplib2.Http(disable_ssl_certificate_validation=True)
            access_token_url = urljoin(args.site, '/api/token')
            resp, cont = h.request(access_token_url, 'POST', access_req, {'Content-Type': 'application/x-www-form-urlencoded'})
            assert resp.status == 200, 'not a 200 but a %d from getting access token: %s' % (resp.status, cont)

            token_data = json.loads(cont)
            args.access_token = ':'.join(token_data[f] for f in ('access_token', 'secret'))
            logging.debug("ACCESS TOKEN: %r", args.access_token)

        self.write_config_file(
            '--site', args.site,
            '--api-key', args.api_key,
            '--api-secret', args.api_secret,
            '--access-token', args.access_token,
        )

        print "Configured!"

    @subcommand(help='list your shakes')
    @authd
    def shakes(self, args, client):
        resp, cont = client.request('/api/shakes')
        assert resp.status == 200, 'not a 200 but a %d from fetching shakes: %s' % (resp.status, cont)
        data = json.loads(cont)

        table = self.table(['ID', 'Name', 'Owner', 'Type', 'URL'])
        for shake in data['shakes']:
            table.add_row([shake['id'], shake['name'], shake['owner']['name'], shake['type'], shake['url']])
        table.printt()

    @subcommand(help='"like" a file into your favorites')
    @argument('sharekey', help='sharekey of the file to like')
    @authd
    def like(self, args, client):
        resp, cont = client.request('/api/sharedfile/%s/like' % args.sharekey.upper(), 'POST', '')
        assert resp.status == 200, 'not a 200 but a %d from "like"ing a file: %s' % (resp.status, cont)
        data = json.loads(cont)
        logging.info("Liked! File has %d likes", data['likes'])

    @subcommand(help='list the most recent "magic" files')
    @authd
    def magic(self, args, client):
        resp, cont = client.request('/api/magicfiles')
        assert resp.status == 200, 'not a 200 but a %d from fetching magic files: %s' % (resp.status, cont)
        data = json.loads(cont)

        table = self.table(['Title', 'Poster', 'Views', 'URL'])
        for magic in data['magicfiles']:
            table.add_row([magic['title'] or magic['name'], magic['user']['name'], magic['views'], magic['permalink_page']])
        table.printt()

    @subcommand(help='upload an image to a shake')
    @argument('file', help='name of the image file to upload')
    @argument('--shake', metavar='ID', help='shake to upload to (default: your user shake)')
    @authd
    def upload(self, args, client):
        request = {
            'file': open(args.file, 'rb'),
        }
        if args.shake:
            request['shake_id'] = args.shake

        class Progressator(object):
            def __init__(self, progressbar):
                self.bar = progressbar
            def show_progress(self, param, current, total):
                if self.bar.maxval is None:
                    self.bar.maxval = total
                    self.bar.start()
                self.bar.update(current)

        register_openers()
        progress = Progressator(self.progressbar())
        bodygen, headers = multipart_encode(request, cb=progress.show_progress)

        uri, auth_header = client.sign_request('/api/upload', 'POST')
        headers['Authorization'] = headers

        exc = None
        request = urllib2.Request(uri, bodygen, headers)
        try:
            urllib2.urlopen(request)
        except urllib2.HTTPError, exc:
            pass
        finally:
            progress.bar.finish()

        if not exc:
            return
        if exc.code == 401:
            # There's a better message in the WWW-Authorize header, if we can get it.
            resp_headers = exc.info()
            www_auth_header = resp_headers.get('www-authenticate')
            if www_auth_header:
                _, _, value = www_auth_header.partition('MAC realm="mlkshk" ')
                if value:
                    www_auth_data = urllib2.parse_keqv_list(urllib2.parse_http_list(value))
                    logging.error('%(error)s error authenticating to MLKSHK: %(error_description)s' % www_auth_data)
                    return

        logging.error(str(exc))


if __name__ == '__main__':
    Mlkshk().run()
